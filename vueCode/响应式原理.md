## Object.defineProperty

```js
  const data = {}
  let name = 'vue'

  // 访问data属性时做一个拦截
  Object.defineProperty(data, 'name', {
    get: function () {
      return name
    },
    set: function (newValue) {
      name = newValue
      // 视图重新渲染...
    }
  })

  // 拦截data对象name属性的访问，在访问data.name时会调用get函数
  console.log(data.name) // vue

  // 监听变化时，会调用set函数
  data.name = 'zlp'
  console.log(data.name) // vue

```
### 基本响应式实现
* 循环data中的属性
* 给属性绑定Object.defineProperty,添加get和set方法，对属性进行拦截
* 访问属性时会调用get方法
* 给属性重新赋值时会调用set方法，并做视图更新操作

```js
let data = {
  name: 'zhangliping',
  age: 26
}

// 变成响应式数据
observer(data)

function observer (target) {
  // 不是对象或者数组则直接return
  if (typeof target !== 'object' || typeof target === null) {
    return target
  }

  // 循环data中的属性
  for (let key in target) {
    defineReactive(target, key, target[key])
  }
}

function defineReactive (target, key, value) {
  Object.defineProperty(target, key, {
    get: function () {
      return value
    },
    set: function (newValue) {
      if (value !== newValue) {
        value = newValue
        // 视图更新
      }
    }
  })
}
```

### 处理值为复杂对象
```js
let data = {
  name: 'zhangliping',
  age: 26,
  like: {
    name: 'a'
  }
}

observer(data)

function observer (target) {
  if (typeof target !== 'object' || typeof target === null) {
    return target
  }

  for (let key in target) {
    defineReactive(target, key, target[key])
  }
}

function defineReactive (target, key, value) {
  // 深度监听value
  // 可深度监听like.name
  observer(value)
  Object.defineProperty(target, key, {
    get: function () {
      return value
    },
    set: function (newValue) {
      // 如果设置的是一个对象，则需要深度监听
      observer(newValue)
      if (value !== newValue) {
        value = newValue
        // 视图更新
      }
    }
  })
}
```
* Object.defineProperty 无法监听到新增和删除属性
* 所以删除需要使用 Vsue.delete
* 新增需要使用 Vue.set

#### vue2 和 vue3 的区别
* proxy 使用时才会去做响应式
* Object.defineProperty 一上来就会将数据循环添加响应式，如果页面数据复杂，则会卡

### 处理数组情况

```js
const oldArrayProto = Array.prototype
const newArrayProty = Object.create(oldArrayProto)

['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => {
  newArrayProty[methodName] = function () {
    oldArrayProto[methodName].call(this, ...arguments)
  }
})

```